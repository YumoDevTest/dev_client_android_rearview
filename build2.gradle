println '***************导入配置项**************'

import org.codehaus.groovy.runtime.StackTraceUtils

int[] sdksAvailable() {
    def sdks = new ByteArrayOutputStream()
    def androidSdkDir = androidSDKDir()
    if (System.getProperty('os.name').contains("Mac")) {
        exec {
            workingDir androidSdkDir + "/tools"
            commandLine './android', 'list'
            standardOutput = sdks
        }
    } else {
        def str = androidSdkDir + File.separator + "tools"
        def str1 = str.substring(0, 2)
        def str2 = str.substring(2)
        exec {
            //     workingDir androidSdkDir + File.separator+"tools"

            commandLine str1
            commandLine 'cd', str2
            commandLine 'android.bat', 'list'
            standardOutput = sdks
        }
    }


    sdks = sdks
            .toString()
            .split('\n')
            .findAll { it ==~ /\s*API level:\s*(\d+).*/ }
            .collect { (it =~ /\s*API level:\s*(\d+).*/)[0][1].toInteger() }
            .sort({ a, b -> b <=> a })

    sdks


}

int highestSdkAvailable(int defaultSdk) {
    try {
        def sdks = sdksAvailable()
        def highestSdk = sdks[1]
        if (highestSdk != null) {
            println "#highest found SDK is " + highestSdk
            highestSdk
        } else {
            println "#No installed SDKs found. Using default SDK " + defaultSdk
            defaultSdk
        }
    } catch (any) {
        println "#Exception while determining highest SDK. Using default SDK " +
                defaultSdk
        StackTraceUtils.sanitize(any).printStackTrace()
        defaultSdk
    }
}
/*我们团队内部建立的编译环境初始化函数
  这个函数的目的是
  1  解析一个名为local.properties的文件，读取AndroidSDK和NDK的路径
  2  获取最终产出物目录的路径。这样，编译完的apk或者jar包将拷贝到这个最终产出物目录中
  3 获取Android SDK指定编译的版本
*/

def initMinshengGradleEnvironment() {
    println "#initialize Minsheng Gradle Environment ....."
    Properties properties = new Properties()
    //local.properites也放在posdevice目录下
//    FilepropertyFile  = new File(rootDir.getAbsolutePath()+ "/local.properties")
//    properties.load(propertyFile.newDataInputStream())
    /*
      根据Project、Gradle生命周期的介绍，settings对象的创建位于具体Project创建之前
      而Gradle底对象已经创建好了。所以，我们把local.properties的信息读出来后，通过
     extra属性的方式设置到gradle对象中
      而具体Project在执行的时候，就可以直接从gradle对象中得到这些属性了！
    */
    gradle.ext.api = properties.getProperty('sdk.api')
    gradle.ext.sdkDir = properties.getProperty('sdk.dir')
    gradle.ext.ndkDir = properties.getProperty('ndk.dir')
    gradle.ext.localDir = properties.getProperty('local.dir')
    //指定debugkeystore文件的位置，debug版apk签名的时候会用到
    gradle.ext.debugKeystore = properties.getProperty('debug.keystore')
    println "#initialize Minsheng Gradle Environment completes..." + gradle.ext.sdkDir
}

String androidSDKDir() {
//    initMinshengGradleEnvironment()
    def androidExecPath = new ByteArrayOutputStream()
    def sdkDirProp
    def rootDir = project.rootDir
    def localProperties = new File(rootDir, "/local.properties")
    if (localProperties.exists()) {
        Properties properties = new Properties()
        localProperties.withInputStream { instr ->
            properties.load(instr)
        }

        sdkDirProp = properties.getProperty('sdk.dir')

        return sdkDirProp
    } /*else if (sdkDirProp != null || sdkDirProp != "") {
        if (System.getProperty('os.name').contains("Mac")) {
            try {
                exec {
                    commandLine 'which', 'android'
                    standardOutput = androidExecPath
                }
                println "find android exec path: " + androidExecPath.toString()
                return (androidExecPath.toString().trim()).getParentFile().getParentFile()
            } catch (ExecException) {
                exec {
                    commandLine 'grep', 'sdk.dir', 'local.properties'
                    standardOutput = androidExecPath
                }
                println "find android sdk with local.properties: " + androidExecPath.toString()
                return androidExecPath.toString().trim().split('=')[1]
            }
        } else {
            exec {
                commandLine 'set', 'ANDROID_HOME'
                standardOutput = androidExecPath
            }
            return (androidExecPath.toString().trim().split('=')[1])
        }

    }*/ else {
        return "f:\\android-sdk_r14-windows\\android-sdk-windows"

    }

}

String[] buildToolsAvailable() {
    println "#sdk dir: " + androidSDKDir()
    def buildToolsDir = new File(androidSDKDir(), "build-tools")
    buildToolsDir.list([accept: { d, f -> !f.contains("android") }] as FilenameFilter).sort { a, b -> b <=> a }
}

String latestBuildToolsAvailable(String defaultBuildTools) {
    try {
        def buildToolsVersions = buildToolsAvailable()
        def latestBuildTools = buildToolsVersions[0]
        buildToolsVersions.each { dir ->
            if (new File(dir).isDirectory()) {
                latestBuildTools = dir;
                println "$dir"
            }
        }
        if (latestBuildTools != null) {
            println "#latest found build tools is " + latestBuildTools
            latestBuildTools
        } else {
            println "#No installed build tools found. Using default build tools " +
                    defaultBuildTools
            defaultBuildTools
        }
    } catch (any) {
        println "#Exception while determining latest build tools. Using default build tools " +
                defaultBuildTools
        StackTraceUtils.sanitize(any).printStackTrace()
        defaultBuildTools
    }
}

//获得 jenkins里配置的环境变量，串口名
def getPara_SERIALPORT_PATH = {
    def var1 = System.getenv('SERIALPORT_PATH')
    if (var1) {
        return var1
    }
    return null
}

//获得 是否伪造IMEI
def getPara_IS_FAKE_IMEI = {
    def var1 = System.getenv('IS_FAKE_IMEI')
    if (var1) {
        return Boolean.parseBoolean(var1)
    }
    return true
}

//获得 伪造的IMEI
def getPara_FAKE_IMEI = {
    def var1 = System.getenv('FAKE_IMEI')
    if (var1) {
        return var1
    }
    return null
}

//获得 功能收费的服务器URL
def getPara_BASE_PERMISSION_URL = {
    def var1 = System.getenv('BASE_PERMISSION_URL')
    if (var1) {
        return var1
    }
    return null
}

//
//def getBuildSDKVersion = { ->
//    def buildSDKVersion = System.getenv("Android_SDK_Version")
//    println "buildSDKVersion is ${buildSDKVersion}"
//    if (buildSDKVersion) {
//        return Integer.parseInt(buildSDKVersion)
//    }
////    if (rootProject.ext.compileSdkVersion) {
////        return rootProject.ext.compileSdkVersion
////    }
//    return Integer.parseInt("22")
//}

def getGitVersion = { ->
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'log', '-1', '--pretty=format:%h'
            standardOutput = stdout
        }
        return stdout.toString()
    } catch (ignored) {
        return '0000000';
    }
}


def getPrefixName = { ->
    def var1 = System.getenv("Prefix_Name")
    if (var1) {
        return var1
    }
    return 'OBD'
}

def getBranchName = { ->
    def var1 = System.getenv("Branch_Name")
    if (var1) {
        var1 = var1.substring(var1.lastIndexOf("/") + 1);
// var1.replace('/', '_');// var1.substring(0, var1.indexOf("/"))
        return var1
    }
    return null
}

//获得版本名称
def getPara_VERSION_NAME = { ->
    def var1 = System.getenv("VERSION_NAME")
    if (var1) {
        return var1;
    }
    return null
}

//获得版本编号
def getPara_VERSION_CODE = { ->
    def var1 = System.getenv("VERSION_CODE")
    if (var1) {
        return Integer.parseInt(var1)
    }
    return null
}

//是否开启 功能收费权限管理
def getPara_IS_ENABLE_PERMISSION = { ->
    def var1 = System.getenv("IS_ENABLE_PERMISSION")
    if (var1) {
        return Boolean.parseBoolean(var1)
    }
    return false
}

ext {
    SERIALPORT_PATH = getPara_SERIALPORT_PATH()
    IS_FAKE_IMEI = getPara_IS_FAKE_IMEI()
    FAKE_IMEI = getPara_FAKE_IMEI()
    BASE_PERMISSION_URL = getPara_BASE_PERMISSION_URL()

    GET_VERSION = getGitVersion()
    PREFIX_NAME = getPrefixName()
    BRANCH_NAME = getBranchName()

    VERSION_NAME = getPara_VERSION_NAME()
    VERSION_CODE = getPara_VERSION_CODE()

    IS_ENABLE_PERMISSION = getPara_IS_ENABLE_PERMISSION()

    IS_JENKINS = !(BRANCH_NAME == null || "".equals(BRANCH_NAME));
}

//ext.compileSdkVersion = highestSdkAvailable(22)
//ext.buildToolsVersion = latestBuildToolsAvailable("23")

println "#读取环境参数,是否处于Jenkins编译环境： ${IS_JENKINS}"
println "#读取环境参数,prefixName is ${PREFIX_NAME}"
println "#读取环境参数,branchName is ${BRANCH_NAME}"
println '#读取环境参数,GitVersion is ' + project.GET_VERSION
//println '#读取环境参数,compileSdkVersion = ' + project.compileSdkVersion
//println '#读取环境参数,buildToolsVersion =' + project.buildToolsVersion
println '#读取环境参数,串口名：' + project.SERIALPORT_PATH
println '#读取环境参数,是否伪造IMEI：' + project.IS_FAKE_IMEI
println '#读取环境参数,伪造的IMEI：' + project.FAKE_IMEI
println '#读取环境参数,版本号(编号)：' + project.VERSION_CODE
println '#读取环境参数,版本号(名称)：' + project.VERSION_NAME
println '#读取环境参数,是否开启 功能收费权限管理：' + project.IS_ENABLE_PERMISSION
println '#读取环境参数,权限服务基础url：' + project.BASE_PERMISSION_URL


println '***************设定图吧obd的sdk的源代码路径**************'
//读取存储在 local.properties的 参数配置。如果使用这个，
//你需要在你的 local.properties的 添加：obd.sdk.source.dir=/Users/zhangyunfei/git/dev_sdk/java/core
Properties properties = new Properties()
File localPropertyFile = project.rootProject.file('local.properties');
if (localPropertyFile.exists()) {
    properties.load(localPropertyFile.newDataInputStream())
    rootProject.ext.obd_sdk_source_dir = properties.getProperty('obd.sdk.source.dir')
    println "#读取到图吧obd的sdk的源代码路径: " + rootProject.ext.obd_sdk_source_dir
}
